<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skill Relationships Hierarchy View</title>
    <link rel="stylesheet" href="css/ontology_hierarchy_view.css">
</head>
<body>
    <div class="hierarchy-container" id="hierarchy-container">
        <!-- Content will be dynamically loaded here -->
        Loading skill hierarchy...
    </div>

    <script>
        async function fetchData(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error(`Error fetching data from ${url}:`, error);
                return null;
            }
        }

        async function loadAndRenderHierarchy() {
            const urlParams = new URLSearchParams(window.location.search);
            const skillId = urlParams.get('skillId');

            const hierarchyContainer = document.getElementById('hierarchy-container');

            if (!skillId) {
                hierarchyContainer.innerHTML = '<p style="color: red;">Error: Skill ID not provided. Please provide a skill ID in the URL (e.g., ?skillId=YOUR_SKILL_ID).</p>';
                return;
            }

            const skillDetails = await fetchData(`/api/v1/ontology/skills/${skillId}/details_full`);
            const skillRelationships = await fetchData(`/api/v1/ontology/skills/${skillId}/relationships`);

            if (!skillDetails) {
                hierarchyContainer.innerHTML = `<p style="color: red;">Error loading details for skill ID: ${skillId}. Could not load skill details.</p>`;
                return;
            }

            const baseSkill = skillDetails.find(item => item.relation_type === 'base_skill');
            if (!baseSkill) {
                hierarchyContainer.innerHTML = `<p style="color: red;">Skill Relationships for: Unknown Skill (ID: ${skillId}). Base skill not found in details.</p>`;
                return;
            }

            renderHierarchy(baseSkill, skillDetails, skillRelationships, hierarchyContainer);
        }

        function renderHierarchy(baseSkill, skillDetails, skillRelationships, containerElement) {
            containerElement.innerHTML = ''; // Clear previous content

            const nodes = new Map(); // id -> { id, name, type, children: [], parentId: null }

            // Add base skill
            nodes.set(baseSkill.id, { ...baseSkill, type: 'core_skill', children: [], parentId: null });

            // Identify key related entities
            const parentCompetency = skillDetails.find(item => item.relation_type === 'parent_competency');
            const grandparentCapability = skillDetails.find(item => item.relation_type === 'grandparent_capability');
            const allChildSkills = skillDetails.filter(item => item.relation_type === 'child_skill');
            const allSiblingSkills = skillDetails.filter(item => item.relation_type === 'sibling_skill');

            // Build the core hierarchy: Capability -> Competency -> Base Skill -> Children
            let currentParent = null;

            if (grandparentCapability) {
                nodes.set(grandparentCapability.id, { ...grandparentCapability, type: 'capability', children: [], parentId: null });
                currentParent = nodes.get(grandparentCapability.id);
            }

            if (parentCompetency) {
                nodes.set(parentCompetency.id, { ...parentCompetency, type: 'competency', children: [], parentId: currentParent ? currentParent.id : null });
                if (currentParent) {
                    currentParent.children.push(parentCompetency.id);
                }
                currentParent = nodes.get(parentCompetency.id);
            }

            // Link base skill
            if (currentParent) {
                nodes.get(baseSkill.id).parentId = currentParent.id;
                currentParent.children.push(baseSkill.id);
            }

            // Add child skills
            allChildSkills.forEach(child => {
                nodes.set(child.id, { ...child, type: 'child_skill', children: [], parentId: baseSkill.id });
                nodes.get(baseSkill.id).children.push(child.id);
            });

            // Add sibling skills (under the same parent as base skill)
            // For display purposes in this grid layout, we'll just pick up to 2 siblings
            const leftSibling = allSiblingSkills[0];
            const rightSibling = allSiblingSkills[1];

            if (leftSibling) {
                nodes.set(leftSibling.id, { ...leftSibling, type: 'sibling_skill', children: [], parentId: baseSkill.id });
            }
            if (rightSibling) {
                nodes.set(rightSibling.id, { ...rightSibling, type: 'sibling_skill', children: [], parentId: baseSkill.id });
            }

            // Render the boxes
            if (grandparentCapability) {
                const gpDiv = createSkillBox('Capability', grandparentCapability.name, 'grandparent');
                containerElement.appendChild(gpDiv);
            }

            if (parentCompetency) {
                const pDiv = createSkillBox('Competency', parentCompetency.name, 'parent');
                containerElement.appendChild(pDiv);
            }

            if (leftSibling) {
                const lsDiv = createSkillBox('Sibling Skill', leftSibling.name, 'sibling left');
                containerElement.appendChild(lsDiv);
            }

            const csDiv = createSkillBox('Core Skill', baseSkill.name, 'center-skill');
            containerElement.appendChild(csDiv);

            if (rightSibling) {
                const rsDiv = createSkillBox('Sibling Skill', rightSibling.name, 'sibling right');
                containerElement.appendChild(rsDiv);
            }

            if (allChildSkills.length > 0) {
                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'children-container';
                
                const initialDisplayCount = 5;
                const childrenToDisplay = allChildSkills.slice(0, initialDisplayCount);
                const hiddenChildren = allChildSkills.slice(initialDisplayCount);

                childrenToDisplay.forEach(child => {
                    const cDiv = createSkillBox('Child Skill', child.name, 'child');
                    childrenContainer.appendChild(cDiv);
                });

                if (hiddenChildren.length > 0) {
                    const viewMoreButton = document.createElement('button');
                    viewMoreButton.className = 'view-more-button';
                    viewMoreButton.textContent = `View More (${hiddenChildren.length} more)`;
                    viewMoreButton.onclick = () => {
                        hiddenChildren.forEach(child => {
                            const cDiv = createSkillBox('Child Skill', child.name, 'child');
                            childrenContainer.insertBefore(cDiv, viewMoreButton.parentNode); // Insert before the button's parent
                        });
                        viewMoreButton.remove(); // Remove the "View More" button
                    };
                    const buttonWrapper = document.createElement('div');
                    buttonWrapper.appendChild(viewMoreButton);
                    childrenContainer.appendChild(buttonWrapper);
                }
                containerElement.appendChild(childrenContainer);
            }
        }

        function createSkillBox(label, name, className) {
            const div = document.createElement('div');
            div.className = `skill-box ${className}`;
            div.innerHTML = `<h3>${label}</h3><p>${name}</p>`;
            return div;
        }

        loadAndRenderHierarchy();
    </script>
</body>
</html>
